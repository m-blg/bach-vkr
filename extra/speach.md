
# Вступление

Идея состоит в том, чтобы часть функционала компилятора Си, вынести в виде пользовательской библиотеки, с возможность ее модифицирования и доработки. 
Это позволяет разработчику процедурно обрабатывать код, что открывает возможность создания автоматизированных систем по работе с кодом.
Пример такой системы реализован в данной работе с применением синтаксического расширения языка Си, добавляющего \textquote{@ директивы}.
Далее язык Си вместе с автоматизированной системой буду называть просто \textquote{Расширенный Си} (англ. \textquote{Extended C}, сокр. \textquote{EC}). 

Данная работа посвящена разработке библиотеки грамматического разбора языка Си и разработке прототипа компилятора\break языка \textquote{Extended C} (\textquote{Расширенный Си}, далее \textquote{EC}) на основе этой библиотеки.

Объектом разработки является source-to-source компилятор \verb|ecc|, языка EC, являющейся небольшой надстройкой над языком Си.
Целью работы является совершенствование инструментария по работе с языком Си.

Задачами ВКР являются обзор и анализ существующих систем метапрограммирования в других языках, 
разработка аналогичной системы для языка EC,
демонстрация практической выгоды данной системы.

основные определения:
слайд с определениями

актуальность:
Язык программирования - основной инструмент любого разработчика.
От его эргономики, то насколько легко на нем излагать идеи, напрямую зависит
продуктивность разработчика

В случае языка Си необходимость линейно упорядочивать определения,
вызванная ограничениями по ресурсам вычислительных устройств того време-
ни, когда он был разработан, и отсутствие функционала метапрограммирова-
ния, понижают его эргономику.

Цель данной работы - повышение эргономики и модернизация языка Си.

Идея состоит в том, чтобы часть функционала компилятора Си, вынести в
виде пользовательской библиотеки, с возможность ее модифицирования и до-
работки. Это позволяет разработчику процедурно обрабатывать код, что откры-
вает возможность создания автоматизированных систем по работе с кодом.

Пример такой системы реализован в данной работе с применением син-
таксического расширения языка Си, добавляющего «@ директивы».
Далее язык Си вместе с автоматизированной системой буду называть про-
сто «Расширенный Си» (англ. «Extended C», сокр. «EC»).


В данной работе представлен source-to-source компилятор языка EC  Extended C Compiler (сокр. ecc), представлющий собой слой предобработки исходного кода языка Си, 
с дополнительным функционалом интерпретации директив синтаксического расширения. 
Компилятор реализован на языке Си23.

постановка задачи:
задачи приведены на слайде

## Пример
На данном примере 

применяются макро-функции

корневые определения предобрабатываются


## аналоги
<!-- сравнение с другими языками или просто упоминание о них -->
подобные системы реализованы и в других языка, например
proc_macro_derive - процедурные макросы вывода в Rust.

или макро-функции в Julia, которые 
Синтаксически почти полностью совпадают с директивами EC.

# Основная часть
2 части
1) демонстрация компилятора
пример
2) рассказ о внутренностях



---


## архитектура
Проект выполнен как динамическая библиотека \verb|libec.so| и небольшая утилита \verb|ecc| использующая ее.

слайд с архитектурой проекта

## пример ast:
Было разработано абстрактное синтаксическое дерево языка Си по его грамматике, приведенной  в стандарте.
На слайде приведена визуализация дерева, полученного при разборе выражения языка

## синтаксические разборы:
Процесс разбора языка идет в два этапа:

При начальном лексическом разборе текст разбивается на последовательность лексем(или токенов),
применяется препроцессор

При грамматическом разборе строится AST. При этом используется разбор методом рекурсивного спуска. 
Для разбора выражений используется парсер Пратта. 
Контекстно зависимые части языка разбираются в два прохода.

## Контекстная зависимость:
Привожу пример контекстной зависимости языка Си. 
Выражение, приведенное сверху, в зависимости от того является ли T именем типа или нет, может быть разобрано двумя способами:
в первом случае это разыменовывание указателя x с последующем преобразование его к типу T.
во втором случае это умножение двух переменных

Поэтому для корректного разбора выражений в Си, нужна система разрешения имен. 
В данной работе она выполнена в виде стека таблиц символов, что позволяет моделировать области видимости переменных.

## @ директивы:
@(эт) директивы имеют следующую грамматику(слайд)

на данный момент аргументами такой директивы могут быть идентификаторы или литералы


## переупорядочивание:
определения переупорядочиваются так как показано на слайде

Выполняется топологическая сортировка определений типов алгоритмом Кана.

### Пример
слева программа на EC, справа содержимое промежуточного C файла

## процесс компиляции макросов:

Макро-функции должны находиться в отдельном файле, т.к. библиотека макро-функций является отдельной единицей трансляции.
При компиляции \verb|ecc| сначала компилирует все макро-функции как динамическую библиотеку, линкуя(или связывая) ее с основной библиотекой \verb|libec.so|, затем динамически подгружает ее в свое виртуальное адресное пространство, после чего возможен вызов данных функций.


Зачастую бывает нецелесообразно генерировать код заполняя AST структуру вручную, альтернативой этому на данный момент служит написание генерируемого кода в виде строки,
используя вспомогательный примитив \verb|StringFormatter|, рассмотренный далее[\ref{primitives:formatter}], и последующий его грамматический разбор.
Функционал грамматического разбора, приведенный в заголовочном файле \verb|proc_macro.h| использует библиотеку \verb|libec.so|.


# Заключение

По итогу ВКР были решены следующие задачи:
	– Изучены стандарты языка Си
	– Разработано абстрактное синтаксическое дерево для языка Си по его CFG и написана библиотека грамматического разбора языка Си
	– Спроектировано синтаксического расширения языка Си
	– Разработан прототип компилятора языка EC
	– Разработана система макросов для языка EC