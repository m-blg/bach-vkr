\chapter{АРХИТЕКТУРА ПРОЕКТА}
\label{ch:ch1}


Требования к окружению:
\begin{itemize}
\item OS: GNU/Linux
\item Наличие компилятора gcc
\end{itemize}

\vspace{5pt}
Проект выполнен как динамическая библиотека \verb|libec.so| и небольшая утилита \verb|ecc| использующая ее.

% Данный функционал предоставлен пользователю для решения задачь метапрограммирования: предобработки, умной компиляции, и др.

% Поверх стандартного фунционала разбора языка Си в библиотеку добавлено синтаксическое расширение языка: Extended C
% Которое может быть использованно пользователем для разметки программного кода с целью последующей его обработки, что продемострированно далее[\ref{use-ex:code-gen}]

\section{Примеры использования}
\subsection{Пример генерации кода Си}




\section{Сравнение с другими языками}
\subsection{Сравнение с языком C}
\label{langcmp:c}
Си - довольно старый системный язык, разработанный Деннисом Ритчи еще в 70х годах прошлого столетия, однако активно применяется и по сей день, среди ярких примеров применения: ядро операционной системы Linux, различные embedded системы.
С тех пор вышло несколько версий языка, среди них самая последняя C23, она же использовалась при написании данной работы.
Си это язык со слабой статической типизацией, благодаря чему во многом предстваляет собой высокоуровневый ассемблер.

В данной работе реализованно небольшое синтаксическое расширение языка Си, представляющее собой своеобразную систему разметки, семантическая часть языка не тронута.
Улучшена эргономика языка за счет автоматического упорядочевания определений(структурный элементов языка) в порядке зависимостей, что было продемострированно выше[\ref{use-ex:order}].



\subsection{Сравнение с языком C++}
C++ является системным языком программирования, доминирующим на рынке в сфере ПО с требованиями по производительности. 
C++ несомненно объемный язык, в нем присутствуют такие системы как:
\begin{itemize}
\item подмножество языка Си
\item расширенная система типов Си
\item статический полиморфизм на перегруженнии функций
\item система шаблонов, которая применяется как для статического полиморфизма, так и для метапрограммирования
\item система пространств имен
\item ООП система с возможностями динамического полиморфизка
\end{itemize}

Все это многообразие делает процесс разрешения имен в C++ очень сложным. 
Некоторые системы C++, например система виртуальных функций, через которые реализуется динамический полиморфизм, 
не дают пользователю контроля на тем как именно виртуальные таблицы распологаются в памяти.

В тех случаях когда этот контроль важен(например при динамическом подгружении и линковке библиотек) зачастую вовсе отказываются данной подсистемы и реализуют аналогичную в стиле Си остальными средствами языка C++.

В философии EC подобные подсистемы должны быть реализованы в виде пользовательских библиотек, с улучшенной эргономикой посредвом макросов, позволяющей расширять язык средствами самого языка.
Так разработчик имеет максимальный контроль над используемыми инструментами, неограничен в их доработке и настройке под конкретный проект.

Так как Си явлется частичным подмножестом языка C++, то пункты приведенные выше[\ref{langcmp:c}] также применяются.

Для C/C++ существует компилятор Clang, у которого frontend выненсен в качестве библиотеки, однако данный компилятор заточен больше на C++, что существенно усложняет Ast, 
поэтому было принято решения написать свой минималистичный frontend для Си.



\subsection{Сравнение с языком Rust}
Rust является системным языком программирования с развитой системой типов, позволяющей проводить глубокий статический анализ, в частности анализ и выведение времени жизни переменных, 
что используется при обнаружение ошибок связанных с владением памятью, таких как
\begin{itemize}
\item использование после освождения памяти(use-after-free)
\item повторное освобождение памяти(double-free) 
\item утечка памяти(memory-leak)
\end{itemize}


В языке Rust представленна система\cite{rust-proc-macro} процедурных макросов, схожая с системой, выполненной в данной работе.
В Rust также есть \verb|Derive| макросы(макросы вывода) дающие такой же функционал, что и \verb|@derive| директивы представленные в данной работе.
Макросы в Rust также компилируются в отдельной единице трансляции(\verb|crate| в терминологии Rust).

Отличие состоит в том, что макросы в Rust работают на уровне токенов(лексем), тогда как макросы в данном проекте работают на уровне элемента AST подобно языку Julia[\ref{langcmp:julia}].

Для сравнения привожу заголовки функций макросов из обоих языков[\ref{langcmp:rust:rust_pmh}, \ref{langcmp:rust:ec_pmh}]:


\begin{lstlisting}[language=C, caption={Заголовок процедурного макроса Rust}, label={langcmp:rust:rust_pmh}]
#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -> TokenStream;
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Заголовок процедурного макроса EC}, label={langcmp:rust:ec_pmh}]
@derive_macro(DebugFormat)
ProcMacroError
gen_dbg_fmt(C_TranslationUnitData *data, C_Ast_Decl *decl, C_Ast_TranslationUnit **out_node);
\end{lstlisting}

Где \verb|TokenStream| - тип потока токенов в языке Rust.

Генерация кода, путем заполнения AST напрямую - трудоемкий и нецелесобразный подход.
Поэтому в Rust есть функционал "цитирования" кода, предоставляемый пакетом(\verb|crate|) \verb|quote|\cite{rust-quote}.
Данный пакет предоставляет макро-функцию \verb|quote!|, реализованную как декларативный макрос(еще один вид макросов) самого языка Rust.

Пример цитирования кода:
\begin{lstlisting}[language=C, caption={Заголовок процедурного макроса Rust}, label={langcmp:rust:rust_quote}]
let varname = format_ident!("_{}", ident);
quote! {
    let mut #varname = 0;
}
\end{lstlisting}

Так мы можем писать генерируемый код, как если бы писали код обычной функции. К тому же есть вожможность подстановки выражений из локальных переменных.
Опять же все это работает на уровне токенов, т.е. макро-функция \verb|quote| возвращает поток токенов, получая блок текста(программы).

В моей работе на данный момент единственный целесобразный способ генерации кода это генерация его в виде строки, с последующим грамматическим разбором, как показано ранее в примере[\ref{use-ex:code-gen}].

Также в EC макро-функциях на вход приходит разобранный AST элемент, тогда как в Rust приходит простой поток токенов.
Для анализа и обработки программы нужно грамматически разобрать его, для этого в Rust есть пользовательский пакет \verb|syn|\cite{rust-syn}, реализующий парсер языка Rust.

Также как в EC порядок следования определений в тексте программы не играет роли в Rust.

\subsection{Сравнение с языком Julia}
\label{langcmp:julia}
Язык Juila это скриптовый язык с динамической типизацией подобно языку Python. Система JIT(just-in-time, точно в срок)-компиляции, использующая LLVM\cite{LLVM} позволяется данному языку компилироваться напрямую в машинный код, 
что благодаря оптимизациям LLVM позволяет добиться производительности близкой к производительности языка Си.

Язык Julia имеет похожую систему макро-функций\cite{julia-meta}, с единственным отличием, что в Julia макро-функции могут идти вперемешку с остальными. 
Связано это с тем, что в Julia определения функций интерпретируются линейно по ходу текста программы, в EC определения интерпретируются вне зависимости от порядка их следования в тексте.

Синтаксически макросы в Julia почти полностью совпадают с директивами EC.

\subsection{Сравнение с языком Zig}
Zig это относительно молодой язык программирования, стремящийся занять туже нишу, что C/C++. 
Также как в Rust продвинутая система типов позволяет этому языку предотвратить множество ошибок при работе с памятью на этапе компиляции.

В языке Zig метапрограммирование выполненно с помощью функционала \verb|comptime| - позволяющего выполнять код во время компиляции и функционала рефлексии, 
позволяющего получить информацию о типе в виде \verb|comptime| структуры, что предоставляет гибкий интерфейс для расширения возможностей компилятора, не прибегая 
к сторонним утилитам, а также для метапрограммирования, не взаимодействуя с AST напрямую.