\chapter{АРХИТЕКТУРА ПРОЕКТА}
\label{ch:ch1}


Требования к окружению:
\begin{itemize}
\item OS: GNU/Linux
\item Наличие компилятора gcc
\end{itemize}

\vspace{5pt}
Проект выполнен как динамическая библиотека \verb|libec.so| и небольшая утилита \verb|ecc| использующая ее.



\section{Сравнение с другими языками}
\subsection{Сравнение с языком C++}
Для C/C++ существует компилятор Clang, у которого frontend выненсен в качестве библиотеки, однако данный компилятор заточен больше на C++, что существенно услоожняет Ast, 
поэтому было принято решения написать свой минималистичный frontend для Си.

\subsection{Сравнение с языком Rust}
В языке Rust представленна система\cite{rust-proc-macro} процедурных макросов, схожая с системой, выполненной в данной работе.
В Rust также есть \verb|Derive| макросы(макросы вывода) дающие такой же функционал, что и \verb|@derive| директивы представленные в данной работе.
Макросы в Rust также компилируются в отдельной единице трансляции(\verb|crate| в терминологии Rust).

Отличие состоит в том, что макросы в Rust работают на уровне токенов(лексем), тогда как макросы в данном проекте работают на уровне элемента AST подобно языку Julia[\ref{langcmp:julia}].

Для сравнения привожу заголовки функций макросов из обоих языков[\ref{langcmp:rust:rust_pmh}, \ref{langcmp:rust:ec_pmh}]:


\begin{lstlisting}[language=C, caption={Заголовок процедурного макроса Rust}, label={langcmp:rust:rust_pmh}]
#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -> TokenStream;
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Заголовок процедурного макроса EC}, label={langcmp:rust:ec_pmh}]
@derive_macro(DebugFormat)
ProcMacroError
gen_dbg_fmt(C_TranslationUnitData *data, C_Ast_Decl *decl, C_Ast_TranslationUnit **out_node);
\end{lstlisting}

Где \verb|TokenStream| - тип потока токенов в языке Rust.

Генерация кода, путем заполнения AST напрямую - трудоемкий и нецелесобразный подход.
Поэтому в Rust есть функционал "цитирования" кода, предоставляемый пакетом(\verb|crate|) \verb|quote|\cite{rust-quote}.
Данный пакет предоставляет макро-функцию \verb|quote!|, реализованную как декларативный макрос(еще один вид макросов) самого языка Rust.

Пример цитирования кода:
\begin{lstlisting}[language=C, caption={Заголовок процедурного макроса Rust}, label={langcmp:rust:rust_quote}]
let varname = format_ident!("_{}", ident);
quote! {
    let mut #varname = 0;
}
\end{lstlisting}

Так мы можем писать генерируемый код, как если бы писали код обычной функции. К тому же есть вожможность подстановки выражений из локальных переменных.
Опять же все это работает на уровне токенов, т.е. макро-функция \verb|quote| возвращает поток токенов, получая блок текста(программы).

В моей работе на данный момент единственный целесобразный способ генерации кода это генерация его в виде строки, с последующим грамматическим разбором, как показано ранее в примере[\ref{use-ex:code-gen}].

Также в EC макро-функциях на вход приходит разобранный AST элемент, тогда как в Rust приходит простой поток токенов.
Для анализа и обработки программы нужно грамматически разобрать его, для этого в Rust есть пользовательский пакет \verb|syn|\cite{rust-syn}, реализующий парсер языка Rust.


\subsection{Сравнение с языком Julia}
\label{langcmp:julia}


\subsection{Сравнение с языком Zig}
В языке Zig метапрограммирование выполненно с помощью функционала \verb|comptime| - позволяющего выполнять код во время компиляции и функционала рефлексии, 
позволяющего получить информацию о типе в виде \verb|comptime| структуры, что предоставляет гибкий интерфейс для расширения возможностей компилятора, не прибегая 
к сторонним утилитам.