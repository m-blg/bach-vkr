
\chapter{ПРЕОБРАЗОВАНИЯ AST}
% \clearpage
\section{Упорядочивание определений}
\label{pass:ordering}

На данном этапе у нас есть массив определений(и возможно оставшихся директив), 
который нам надо преобразовать так, чтобы его смог скомпилировать компилятор языка Си.

Для этого нам нужно расположить все определения следующим образом:

Сначала идут оставшиеся директивы, например:
\begin{lstlisting}[language=c]
@post_include("demo.ec")    
\end{lstlisting}

Затем идут предекларации типов, например:
\begin{lstlisting}[language=c]
struct Foo;
typedef struct Foo Foo;
\end{lstlisting}

Затем сами типы, упорядоченные топологически по графу зависимостей между ними, например:
\begin{lstlisting}[language=c]
struct C {
    B *bp;
};
struct B {
    A *ap;
    C c;
};
struct A {
    B b;
};
\end{lstlisting}

Далее идут определения глобальных переменных, например:
\begin{lstlisting}[language=c]
int g_x;
\end{lstlisting}

Далее заголовки функций, например:
\begin{lstlisting}[language=c]
void bar();
void foo(int x);
\end{lstlisting}

В конце идут определения функций, например:
\begin{lstlisting}[language=c]
void bar() {
    foo(g_x);
}
void foo(int x) {
    print_fmt(S("x: %d\n"), x);
}
\end{lstlisting}

Заметим, что определения типов это единственное место, где нужно делать топологическую сортировку, 
т.к. определения функций зависят только от имен других функций, типов, глобальных переменных, которые идут ранее в порядке декларации.

Для того, чтобы упорядочить определения таким образом мы сначала проходим весь список определений в цикле, распределяя их по группам:
определения переменных, определения функций и те что надо отсортировать. Определения переменных и функций хранятся в массивах, сортируемые хранятся сразу на узлах графа в хеш-таблице.
Оставшиеся директивы сразу записываются в выходной массив, т.к идут первыми. Предекларации составных типов игнорируются.
Для сортируемых рекурсивным обходом его AST формируются хеш-множества зависимостей для сортируемого элемента, данные множества добавляются в соответствующие хеш-таблицы графов.
Замечание: собираются только \textquote{сильные} зависимости т.е. те, где тип приведен без указателя.

Итак в процессе вывода зависимостей строятся два графа сам граф зависимостей \verb|deps_table| и его копия с развернутыми ребрами \verb|f_deps_table|.
Далее два графа сливаются в один \verb|deps_table|.
Для каждого узла переменная \verb|in_deg| устанавливается равной кол-ву зависимостей данного узла.
Формируется массив узлов, для которых переменна \verb|in_deg| равна 0.
После чего запускается алгоритм топологической сортировки[\ref{pass:ordering:topsort}].

Далее в выходной массив из отсортированного массива типов генерируются предекларации, что нужно для разрешения зависимостей по указателю(в моей терминологии \textquote{слабых}).
Далее из отсортированного пишутся сами определения типов.
Затем пишутся определения переменных.
Затем из массива определений функций генерируются их заголовки.
Затем пишутся сами определения функции.

\section{Алгоритм топологической сортировки}
\label{pass:ordering:topsort}

Для топологической сортировки определений используется алгоритм Кана. Данный алгоритм топологически сортирует направленный ациклический граф
Данный алгоритм требует входные данные: 
\begin{itemize}
\item сам направленный ациклический граф $G$
\item множество начальных элементов графа $G$ - те элементы, у которых нет предков, т.е. их входная степень равна нулю
\item множество переменных входных степеней элементов графа $G$ - изначально значение каждой переменной равно значению кол-ва предков для соответствующей вершины или входной степени этой вершины
\item выходной массив $O$, который изначально пустой
\end{itemize}

Алгоритм использует стек в процессе своей работы, в моей реализации подразумевается, что на стеке оказываются элементы, у которых текущая входная степень равна нулю.

\begin{enumerate}
    \item множество начальных элементов кладется на стек в произвольном порядке

    \item пока стек не пуст выполняется:
    \begin{enumerate}
        \item со стека снимается элемент $E$
        \item элемент $E$ добавляется в выходной массив $O$
        \item для любого соседнего элемента $D$ вершины $E$ выполняется: 
        \begin{enumerate}
            \item понизь текущую степень $D$ на 1
            \item если текущая степень $D$ равна 0, добавь $D$ на стек
        \end{enumerate}
    \end{enumerate}

    \item сравниваются величины $\abs{G}$ $\abs{O}$, если они различаются, значит в графе присутствует цикл и алгоритм возвращает ошибку
\end{enumerate}

Привожу реализацию[\ref{pass:ordering:kahn-impl}] данного алгоритма для сортировки символов по зависимостям между ними:

\begin{lstlisting}[language=c, caption={Реализация алгоритма Кана}, label={pass:ordering:kahn-impl}]
bool
symbol_topsort(darr_T(C_Symbol) initials, C_SymbolTable table, darr_T(C_Symbol) *out_sorted, Allocator *alloc) {
    darr_t sorted;
    ASSERT_OK(darr_new_cap_in_T(C_Symbol, hashmap_len(table), alloc, &sorted));

    darr_t stack = initials;

    while (darr_len(stack) > 0) {
        C_Symbol cur = *darr_get_iT(C_Symbol, stack, -1);
        darr_pop(&stack);
        usize_t *cur_in_deg = &hashmap_get_T(C_SymbolData, table, &cur)->in_deg;
        ASSERT(*cur_in_deg == 0);

        hashset_T(C_Symbol) f_deps = hashmap_get_T(C_SymbolData, table, &cur)->f_deps;
        for_in_range(i, 0ul, hashset_len(f_deps)) {
            C_Symbol f_dep = *slice_get_T(C_Symbol, &hashset_values_raw(f_deps), i);
            usize_t *f_dep_in_deg = &hashmap_get_T(C_SymbolData, table, &f_dep)->in_deg;
            ASSERT(*f_dep_in_deg > 0);
            *f_dep_in_deg -= 1;
            if (*f_dep_in_deg == 0) {
                ASSERT_OK(darr_push(&stack, &f_dep));
            }
        }

        ASSERT_OK(darr_push(&sorted, &cur));
    }

    if (darr_len(sorted) != hashmap_len(table)) {
        return false;
    }

    *out_sorted = sorted;

    return true;
}
\end{lstlisting}

Реализация данного алгоритма принимает динамический массив начальных символов, граф в виде хеш-таблицы, элементы которой хранят соседей элемента графа в виде хеш-множества, а также количество предков данного элемента.

% Код данного прохода представлен в приложении[\ref{extras:pass:ordering}]
